# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

#
# NOTES:
#
# This is a starting point for a validation workflow that can detect the specs that
# have changed in a given git commit, build the RPMs for those specs, and run ptests
# for those.
#
# Known limitations/concerns:
#
# * We hard-code -j30 in make invocations; should we?
# 
# * We build + test the packages in an Ubuntu VM runner. This is easiest in a GitHub
#   action, since it's the only Linux OS supported running in the VM; in time,
#   it may be worthwhile looking into running the package build itself in an
#   Azure Linux 3.0 container.
#
# * We take a specific dependency on daily repos in Azure Linux 3.0+, as well as the
#   Azure Linux 3.0 container. To extend support to 2.0, some work will be required
#   to make these dependencies conditional.
#
# * Packages without %check sections will have failed test runs.
#
# * This workflow doesn't know which specs' tests are *expected* to pass (i.e., baseline).
#   We should consider expressing this baseline within this repo.
#

name: "Spec Build/Test"

on:
  # N.B. For now we enable this for 3.0-dev, but expect that the logic below will work
  # for other branches as well.
  push:
    branches: [3.0-dev]
  pull_request:
    branches: [3.0-dev]
  workflow_dispatch:
    inputs:
      comparison_base_ref:
        description: 'The base ref to compare changest against.'
        required: true
        default: 'refs/heads/3.0-dev'

env:
  # For consistency, we use the same major/minor version of the latest version of Python that
  # Azure Linux ships.
  PYTHON_VERSION: "3.12"

jobs:
  detect-changes:
    name: 'Detect spec changes'
    runs-on: ubuntu-latest

    outputs:
      updated_specs: ${{ steps.export.outputs.UPDATED_SPECS }}
      target_ref: ${{ steps.export.outputs.TARGET_REF }}
      azl_extra_make_args: ${{ steps.export.outputs.AZL_EXTRA_MAKE_ARGS }}

    steps:
      - name: Checkout sources
        uses: actions/checkout@v4

      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python dependencies for tools
        run: python3 -m pip install -r toolkit/scripts/requirements.txt

      #
      # We first get oriented, figuring out which version of the code we're building
      # and which version of the code we should be comparing against.
      #
      # We define the following:
      #   - base_sha: The commit hash of the commit we're comparing against.
      #   - target_ref: The ref we're building.
      #

      - name: "Find base commit (PRs)"
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          # In a PR workflow, 'github.base_ref' is the *target* branch of the PR.
          git fetch origin ${{ github.base_ref }}
          echo "base_sha=$(git rev-parse origin/${{ github.base_ref }})" >>$GITHUB_ENV
          echo "target_ref=${{ github.base_ref }}" >>$GITHUB_ENV
          echo "Merging ${{ github.sha }} into ${{ github.base_ref }}"

      - name: "Find base commit (pushes)"
        if: ${{ github.event_name == 'push' }}
        run: |
          # In a push workflow, 'github.event.before' is the SHA hash of the commit
          # immediately preceding the commit being pushed. 
          git fetch origin ${{ github.event.before }}
          echo "base_sha=${{ github.event.before }}" >>$GITHUB_ENV
          echo "target_ref=${{ github.ref }}" >>$GITHUB_ENV
          echo "Merging ${{ github.sha }} into ${{ github.event.before }}"

      - name: "Find base commit (manual)"
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          # In a manually triggered workflow, we don't necessarily have a base commit to compare against.
          # We rely on inputs providing it.
          echo "base_sha=$(git rev-parse ${{ inputs.comparison_base_ref }})" >>$GITHUB_ENV
          echo "target_ref=${{ github.ref }}" >>$GITHUB_ENV
          echo "Building ${{ github.ref }} and comparing against ${{ inputs.comparison_base_ref }}"

      - name: Compute tooling args
        run: |
          # TODO: We naively assume that this is a 3.0+ version that will have a daily build.
          # To support older versions, some work may be required.
          echo 'azl_extra_make_args=DAILY_BUILD_ID=lkg' >>$GITHUB_ENV

      - name: Infer changed specs
        run: |
          updated_specs=$(./toolkit/scripts/detect_changes.py --since ${{ env.base_sha }} --spec-names-only)
          echo "Specs updated: '${updated_specs}'"
          echo "updated_specs=$(echo ${updated_specs})" >>$GITHUB_ENV

      - name: Export outputs
        id: export
        run: |
          echo "UPDATED_SPECS=${{ env.updated_specs }}" >>$GITHUB_OUTPUT
          echo "TARGET_REF=${{ env.target_ref }}" >>$GITHUB_OUTPUT
          echo "AZL_EXTRA_MAKE_ARGS=${{ env.azl_extra_make_args }}" >>$GITHUB_OUTPUT

  build:
    name: 'Build RPMS'
    runs-on: ubuntu-latest
    needs: [detect-changes]
    env:
      updated_specs: ${{ needs.detect-changes.outputs.updated_specs }}
      azl_extra_make_args: ${{ needs.detect-changes.outputs.azl_extra_make_args }}

    outputs:
      daily_build_id: ${{ steps.find-daily-repo.outputs.DAILY_BUILD_ID }}
      daily_build_arch: ${{ steps.find-daily-repo.outputs.DAILY_BUILD_ARCH }}

    steps:
      - name: Checkout sources
        uses: actions/checkout@v4

      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python dependencies for tools
        run: python3 -m pip install -r toolkit/scripts/requirements.txt

      - name: Find daily repo
        id: find-daily-repo
        run: |
          DAILY_BUILD_ID=$(toolkit/scripts/get_lkg_id.sh /tmp)
          echo "DAILY_BUILD_ID=${DAILY_BUILD_ID}" >>$GITHUB_OUTPUT
          echo "DAILY_BUILD_ARCH=x86-64" >>$GITHUB_OUTPUT

      - name: Build modified specs
        id: build-specs
        run: |
          sudo make -C toolkit \
            build-packages \
            $azl_extra_make_args \
            -j30 \
            REBUILD_TOOLS=y \
            SRPM_PACK_LIST='${{ env.updated_specs }}'

      - name: Upload built RPMs
        uses: actions/upload-artifact@v4
        with:
          name: rpms
          path: out/RPMS

      - name: Upload build logs
        id: upload-build-logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ github.run_attempt }}
          path: build/logs

      - name: Publish result
        if: always()
        run: |
          if [[ ${{ steps.build-specs.outcome }} == 'success' ]]; then
            echo "✅ Build succeeded" >>${GITHUB_STEP_SUMMARY}
          else
            echo "❌ Build failed" >>${GITHUB_STEP_SUMMARY}
          fi

      - name: Advertise build logs
        if: always() && steps.upload-build-logs.outcome == 'success'
        run: |
          echo "_Build logs available [for download](${{ steps.upload-build-logs.outputs.artifact-url }})_" >>${GITHUB_STEP_SUMMARY}

  test:
    name: 'Run component tests (ptests)'
    runs-on: ubuntu-latest
    needs: [detect-changes]
    env:
      updated_specs: ${{ needs.detect-changes.outputs.updated_specs }}
      azl_extra_make_args: ${{ needs.detect-changes.outputs.azl_extra_make_args }}

    steps:
      - name: Checkout sources
        uses: actions/checkout@v4

      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python dependencies for tools
        run: python3 -m pip install -r toolkit/scripts/requirements.txt

      - name: Test modified specs
        run: |
          set -euxo pipefail

          sudo make -C toolkit \
            build-packages \
            $azl_extra_make_args \
            -j30 \
            REBUILD_TOOLS=y \
            SRPM_PACK_LIST='${{ env.updated_specs }}' TEST_RUN_LIST='${{ env.updated_specs }}' \
            RUN_CHECK=y

          # Make sure logs are world-readable.
          sudo chown -R $USER:$USER build/logs

          # Inventory logs.
          ls -l build/logs/pkggen/rpmbuilding

          # Look to see what failed. When packages build but tests fail, the make invocation
          # succeeds, but failure logs are left behind. Thankfully there are well-known
          # "failure" logs specifically emitted for test failures, and we can easily
          # glob-find them. In the future, we really should update the toolkit to emit
          # the test results in a machine-readable format so we don't have to scrape this out.
          shopt -s nullglob
          declare -a error_logs=(build/logs/pkggen/rpmbuilding/*FAILED*)
          error_count=${#error_logs[@]}

          if [[ ${error_count} != 0 ]]; then
            # Invoke our helper script to process the check logs and generate markdown output.
            ./toolkit/scripts/process_check_logs.py --log-dir ./build/logs/pkggen/rpmbuilding --output-md ${GITHUB_STEP_SUMMARY}
            exit 1
          fi

      - name: Upload logs
        id: upload-test-logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs-${{ github.run_attempt }}
          path: build/logs

      - name: Post results
        if: always() && steps.upload-test-logs.outcome == 'success'
        run: |
          echo "_Test logs available [for download](${{ steps.upload-test-logs.outputs.artifact-url }})_" >>${GITHUB_STEP_SUMMARY}

  install:
    name: 'Test installing RPM'
    needs: [build, detect-changes]
    runs-on: ubuntu-latest
    container:
      # Use a base Azure Linux 3.0 container.
      image: mcr.microsoft.com/azurelinux/base/core:3.0
      env:
        daily_build_id: ${{ needs.build.outputs.daily_build_id }}
        daily_build_arch: ${{ needs.build.outputs.daily_build_arch }}

          # Reference: https://github.com/Azure/azure-cli/issues/29835
        GNUPGHOME: /root/.gnupg

    defaults:
      run:
        shell: bash
    env:
      target_ref: ${{ needs.detect-changes.outputs.target_ref }}

    steps:
      - name: Install prerequisites
        run: |
          tdnf install -y ca-certificates jq tar wget

      - name: Checkout sources
        uses: actions/checkout@v4

      - name: Download built RPMs
        uses: actions/download-artifact@v4
        with:
          name: rpms
          path: RPMS

      - name: Inventory downloaded RPMs
        run: |
          set -euxo pipefail
          ls -l -R RPMS
          find RPMS -type f -name "*.rpm" ! -name "*.src.rpm" ! -name "*debuginfo*" >rpms.txt
          cat rpms.txt

      - name: Switch container OS to use daily repo
        if: ${{ env.target_ref == '3.0-dev' }}
        run: |
          set -euxo pipefail
          rm -f /etc/yum.repos.d/*
          daily_build_repo_name=daily-repo-${daily_build_id}-${daily_build_arch}

          # Use the daily repo template in the toolkit to generate the right repo file for us.
          sed -e "s|{{.DAILY_REPO_NAME}}|${daily_build_repo_name}|g" \
            toolkit/resources/manifests/package/daily_build_repo.repo.template \
            >/etc/yum.repos.d/daily.repo

      - name: Update container OS
        run: tdnf update -y
        
      - name: Install RPMs
        run: |
          set -euxo pipefail

          # First try installing with tdnf.
          result=0
          tdnf install -y --rpmverbosity=debug $(cat rpms.txt) || result=$?

          # If we fail, try again with dnf instead and hope for better error
          # messages.
          if [[ $result != 0 ]]; then
            echo "Failed to install RPMs with tdnf; trying with dnf."
            tdnf install -y dnf dnf-plugins-core
            dnf install -y --verbose --debuglevel 10 --rpmverbosity=debug $(cat rpms.txt) || true
          fi

          # Pass back the exit code from tdnf.
          exit $result
